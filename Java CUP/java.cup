import java_cup.runtime.*;

parser code  {:
  public void report_error(String message, Object info) {
    StringBuilder m = new StringBuilder("Error ");

    if (info instanceof java_cup.runtime.Symbol)
      m.append( "("+info.toString()+")" );

    m.append(" : "+message);

    System.out.println(m);
  }

  public void report_fatal_error(String message, Object info) {
    report_error(message, info);
    throw new RuntimeException("Fatal Syntax Error");
  }
:};

terminal INT, LONG, CHAR; // integral_type
terminal FLOAT; // floating_point_type
terminal LBRACK, RBRACK; // array_type
terminal SEMICOLON, MULT, COMMA, LBRACE, RBRACE, EQ, LPAREN, RPAREN, COLON;
terminal VOID; // method_header
terminal IF, ELSE; // if_then_statement, if_then_else_statement
terminal WHILE, REPEAT; // while_statement
terminal RETURN; // return_statement
terminal PLUS, MINUS, COMP, DIV;
terminal IS, ISNOT; // equality_expression
terminal AND; // and_expression
terminal OR;  // inclusive_or_expression

// Reserved but unused:
terminal GOTO;

// 19.2) The Syntactic Grammar
non terminal goal;
// 19.3) Lexical Structure
non terminal literal;
// 19.4) Types, Values, and Variables
non terminal type, primitive_type, numeric_type;
non terminal integral_type, floating_point_type;
non terminal reference_type;
non terminal array_type;
// 19.5) Names
non terminal name, simple_name, qualified_name;
// 19.6) Packages
non terminal compilation_unit;
non terminal package_declaration_opt, package_declaration;
non terminal import_declarations_opt, import_declarations;
non terminal type_declarations_opt, type_declarations;
non terminal import_declaration;
non terminal single_type_import_declaration;
non terminal type_import_on_demand_declaration;
non terminal type_declaration;
// 19.7) Productions used only in the LALR(1) grammar
non terminal modifiers_opt, modifiers, modifier;

// 19.8.2) Field Declarations
non terminal field_declaration, variable_declarators, variable_declarator;
non terminal variable_declarator_id, variable_initializer;
// 19.8.3) Method Declarations
non terminal method_declaration, method_header, method_declarator;
non terminal formal_parameter_list_opt, formal_parameter_list;
non terminal formal_parameter;
non terminal throws_opt, throws;
non terminal class_type_list, method_body;
// 19.8.4) Static Initializers
non terminal static_initializer;

// 19.9.1) Interface Declarations
non terminal interface_declaration;
non terminal extends_interfaces_opt, extends_interfaces;
non terminal interface_body;
non terminal interface_member_declarations_opt, interface_member_declarations;
non terminal interface_member_declaration, constant_declaration;
non terminal abstract_method_declaration;
// 19.10) Arrays
non terminal array_initializer;
non terminal variable_initializers;
// 19.11) Blocks and Statements
non terminal block;
non terminal block_statements_opt, block_statements, block_statement;
non terminal local_variable_declaration_statement, local_variable_declaration;
non terminal statement, statement_no_short_if;
non terminal statement_without_trailing_substatement;
non terminal empty_statement;
non terminal labeled_statement, labeled_statement_no_short_if;
non terminal expression_statement, statement_expression;
non terminal if_then_statement;
non terminal if_then_else_statement, if_then_else_statement_no_short_if;
non terminal while_statement, while_statement_no_short_if;
non terminal do_statement;
non terminal statement_expression_list;
non terminal identifier_opt;
non terminal break_statement, continue_statement;
non terminal return_statement, throw_statement;
non terminal synchronized_statement, try_statement;
non terminal catches_opt, catches, catch_clause;
// 19.12) Expressions
non terminal primary, primary_no_new_array;
non terminal class_instance_creation_expression;
non terminal argument_list_opt, argument_list;
non terminal array_creation_expression;
non terminal dim_exprs, dim_expr, dims_opt, dims;
non terminal method_invocation, array_access;
non terminal postfix_expression;
non terminal postincrement_expression, postdecrement_expression;
non terminal unary_expression, unary_expression_not_plus_minus;
non terminal preincrement_expression, predecrement_expression;
non terminal cast_expression;
non terminal multiplicative_expression, additive_expression;
non terminal shift_expression, relational_expression, equality_expression;
non terminal and_expression, exclusive_or_expression, inclusive_or_expression;
non terminal conditional_and_expression, conditional_or_expression;
non terminal conditional_expression, assignment_expression;
non terminal assignment;
non terminal left_hand_side;
non terminal assignment_operator;
non terminal expression_opt, expression;



start with goal;

// 19.2) The Syntactic Grammar
goal ::=	compilation_unit
	;

// 19.3) Lexical Structure.
literal ::=	INTEGER_LITERAL
	|	FLOATING_POINT_LITERAL
	|	BOOLEAN_LITERAL
	|	CHARACTER_LITERAL
	|	STRING_LITERAL
	|	NULL_LITERAL
	;

// 19.4) Types, Values, and Variables
type	::=	numeric_type
	    |	array_type
	;

numeric_type::=	integral_type
	|	FLOAT
	;

integral_type ::= INT
	          |	  LONG
	          |	  CHAR
;


array_type ::=	numeric_type dims
	       |	name dims
;

// 19.5) Names
name	::=	IDENTIFIER
;


variable_declarators ::= variable_declarator
	                 |	 variable_declarators COMMA variable_declarator
;
variable_declarator ::= variable_declarator_id
	                |	variable_declarator_id EQ variable_initializer
;
variable_declarator_id ::= IDENTIFIER
	                   |   variable_declarator_id LBRACK RBRACK
;
variable_initializer ::= expression
	                 |	 array_initializer
;

// 19.8.3) Method Declarations
method_declaration ::= method_header method_body
;
method_header ::= type method_declarator
	          |	  VOID method_declarator
;

method_declarator ::= IDENTIFIER LPAREN formal_parameter_list_opt RPAREN
;

formal_parameter_list_opt ::= formal_parameter_list
	                      |
;

formal_parameter_list ::= formal_parameter
	                  |	  formal_parameter_list COMMA formal_parameter
;
formal_parameter ::= type variable_declarator_id
;

method_body ::=	block
	|	SEMICOLON
;

// 19.10) Arrays
array_initializer ::= LBRACE variable_initializers RBRACE
	              |	  LBRACE RBRACE
;

variable_initializers ::= variable_initializer
	                  |	  variable_initializers COMMA variable_initializer
;

// 19.11) Blocks and Statements
block ::= LBRACE block_statements_opt RBRACE
;

block_statements_opt ::= block_statements
                	 |
;

block_statements ::= block_statement
	             |	 block_statements block_statement
;

block_statement ::= local_variable_declaration_statement
	            |	statement
;

local_variable_declaration_statement ::= local_variable_declaration SEMICOLON
;

local_variable_declaration ::= type variable_declarators
;

statement ::=	statement_without_trailing_substatement
	|	if_then_statement
	|	if_then_else_statement
	|	while_statement
	;
statement_no_short_if ::=
		statement_without_trailing_substatement
	|	labeled_statement_no_short_if
	|	if_then_else_statement_no_short_if
	|	while_statement_no_short_if
	;
statement_without_trailing_substatement ::=
		block
	|	empty_statement
	|	expression_statement
	|	return_statement
	;
empty_statement ::=
		SEMICOLON
	;
labeled_statement_no_short_if ::=
		IDENTIFIER COLON statement_no_short_if
	;
expression_statement ::= statement_expression SEMICOLON
	;
statement_expression ::= assignment
	                 |   method_invocation
;

if_then_statement ::= IF LPAREN expression RPAREN statement
;

if_then_else_statement ::= IF LPAREN expression RPAREN statement_no_short_if ELSE statement
;

if_then_else_statement_no_short_if ::=
		IF LPAREN expression RPAREN statement_no_short_if
			ELSE statement_no_short_if
	;

while_statement ::=
		WHILE LPAREN expression RPAREN statement
	;
while_statement_no_short_if ::=
		WHILE LPAREN expression RPAREN statement_no_short_if
	;

statement_expression_list ::=
		statement_expression
	|	statement_expression_list COMMA statement_expression
	;

identifier_opt ::=
	|	IDENTIFIER
	;

return_statement ::=
		RETURN expression_opt SEMICOLON

// 19.12) Expressions
primary ::=	primary_no_new_array
	|	array_creation_expression
	;
primary_no_new_array ::=
		literal
	|	THIS
	|	LPAREN expression RPAREN
	|	class_instance_creation_expression
	|	method_invocation
	|	array_access
	|	primitive_type DOT CLASS
	|	VOID DOT CLASS
	|	array_type DOT CLASS
	|	name DOT CLASS
	|	name DOT THIS
	;
class_instance_creation_expression ::=
		NEW class_type LPAREN argument_list_opt RPAREN
	|	NEW class_type LPAREN argument_list_opt RPAREN class_body
	|	primary DOT NEW IDENTIFIER
			LPAREN argument_list_opt RPAREN
	|	primary DOT NEW IDENTIFIER
			LPAREN argument_list_opt RPAREN class_body
	;
argument_list_opt ::=
	|	argument_list
	;
argument_list ::=
		expression
	|	argument_list COMMA expression
	;
array_creation_expression ::=
		NEW primitive_type dim_exprs dims_opt
	|	NEW class_or_interface_type dim_exprs dims_opt
	|	NEW primitive_type dims array_initializer
	|	NEW class_or_interface_type dims array_initializer
	;
dim_exprs ::=	dim_expr
	|	dim_exprs dim_expr
	;
dim_expr ::=	LBRACK expression RBRACK
	;
dims_opt ::=
	|	dims
	;
dims ::=	LBRACK RBRACK
	|	dims LBRACK RBRACK
	;

method_invocation ::= name LPAREN argument_list_opt RPAREN
;

array_access ::=
		name LBRACK expression RBRACK
	|	primary_no_new_array LBRACK expression RBRACK
	;
postfix_expression ::=
		primary
	|	name
	|	postincrement_expression
	|	postdecrement_expression
	;
postincrement_expression ::=
		postfix_expression PLUSPLUS
	;
postdecrement_expression ::=
		postfix_expression MINUSMINUS
	;
unary_expression ::=
		preincrement_expression
	|	predecrement_expression
	|	PLUS unary_expression
	|	MINUS unary_expression
	|	unary_expression_not_plus_minus
	;
preincrement_expression ::=
		PLUSPLUS unary_expression
	;
predecrement_expression ::=
		MINUSMINUS unary_expression
	;
unary_expression_not_plus_minus ::=
		postfix_expression
	|	COMP unary_expression
	|	NOT unary_expression
	|	cast_expression
	;
cast_expression ::=
		LPAREN primitive_type dims_opt RPAREN unary_expression
	|	LPAREN expression RPAREN unary_expression_not_plus_minus
	|	LPAREN name dims RPAREN unary_expression_not_plus_minus
	;
multiplicative_expression ::=
		unary_expression
	|	multiplicative_expression MULT unary_expression
	|	multiplicative_expression DIV unary_expression
	|	multiplicative_expression MOD unary_expression
	;
additive_expression ::=
		multiplicative_expression
	|	additive_expression PLUS multiplicative_expression
	|	additive_expression MINUS multiplicative_expression
	;
shift_expression ::=
		additive_expression
	|	shift_expression LSHIFT additive_expression
	|	shift_expression RSHIFT additive_expression
	|	shift_expression URSHIFT additive_expression
	;

equality_expression ::=
		relational_expression
	|	equality_expression IS relational_expression
	|	equality_expression ISNOT relational_expression
	;

    and_expression ::=
    		equality_expression
    	|	and_expression AND equality_expression
    	;
    exclusive_or_expression ::=
    		and_expression
    	|	exclusive_or_expression XOR and_expression
    	;
    inclusive_or_expression ::=
    		exclusive_or_expression
    	|	inclusive_or_expression OR exclusive_or_expression
    	;

conditional_and_expression ::= inclusive_or_expression
	                       |   conditional_and_expression ANDAND inclusive_or_expression
;

conditional_or_expression ::=  conditional_and_expression
	                      |	conditional_or_expression OROR conditional_and_expression
;

conditional_expression ::= conditional_or_expression
;

assignment_expression ::= conditional_expression
	                  |	  assignment
;

assignment ::=	left_hand_side assignment_operator assignment_expression
;

left_hand_side ::= name
	           |   array_access
;

assignment_operator ::= EQ
;

expression_opt ::= expression
	           |
;

expression ::=	assignment_expression
;
