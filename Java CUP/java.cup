import java_cup.runtime.*;

parser code  {:
  public void report_error(String message, Object info) {
    StringBuilder m = new StringBuilder("Error ");

    if (info instanceof java_cup.runtime.Symbol)
      m.append( "("+info.toString()+")" );

    m.append(" : "+message);

    System.out.println(m);
  }

  public void report_fatal_error(String message, Object info) {
    report_error(message, info);
    throw new RuntimeException("Fatal Syntax Error");
  }
:};

terminal IDENTIFIER;
terminal INT, LONG, CHAR; // integral_type
terminal FLOAT; // floating_point_type
terminal LBRACK, RBRACK; // array_type
terminal SEMICOLON, MULT, COMMA, LBRACE, RBRACE, EQ, LPAREN, RPAREN, QUOTE, LT, GT;
terminal VOID; // method_header
terminal IF, ELSE; // if_then_statement, if_then_else_statement
terminal WHILE, REPEAT; // while_statement
terminal RETURN; // return_statement
terminal PLUS, MINUS, DIV;
terminal IS, ISNOT; // equality_expression
terminal AND; // and_expression
terminal OR;  // inclusive_or_expression
terminal ARRAY;
terminal INTEGER_LITERAL, FLOATING_POINT_LITERAL, BOOLEAN_LITERAL, CHARACTER_LITERAL, NULL_LITERAL;

// Reserved but unused:

// 19.2) The Syntactic Grammar
non terminal goal;
// 19.3) Lexical Structure
non terminal literal;
// 19.4) Types, Values, and Variables
non terminal type, numeric_type;
non terminal integral_type, string_literal, characters;
// 19.5) Names
non terminal name;
// 19.6) Packages
non terminal compilation_unit;
// 19.7) Productions used only in the LALR(1) grammar

// 19.8.2) Field Declarations
non terminal variable_declarators, variable_declarator;
non terminal variable_declarator_id, variable_initializer;
// 19.8.3) Method Declarations
non terminal method_declaration, method_header, method_declarator;
non terminal formal_parameter_list_opt, formal_parameter_list;
non terminal formal_parameter;
non terminal method_body;

// 19.10) Arrays
non terminal array_initializer;
non terminal variable_initializers, comma_seperated_values;
// 19.11) Blocks and Statements
non terminal block;
non terminal block_statements_opt, block_statements, block_statement;
non terminal local_variable_declaration_statement, local_variable_declaration;
non terminal statement;
non terminal statement_without_trailing_substatement;
non terminal empty_statement;
non terminal expression_statement, statement_expression;
non terminal if_then_statement;
non terminal if_then_else_statement;
non terminal while_statement;
non terminal return_statement;
// 19.12) Expressions
non terminal primary, primary_no_new_array;
non terminal argument_list_opt, argument_list;
non terminal array_creation_expression;
non terminal method_invocation, array_access;
non terminal postfix_expression;
non terminal unary_expression, unary_expression_not_plus_minus;
non terminal cast_expression;
non terminal multiplicative_expression, additive_expression;
non terminal relational_expression, equality_expression;
non terminal and_expression, or_expression;
non terminal assignment_expression;
non terminal assignment;
non terminal left_hand_side;
non terminal assignment_operator;
non terminal expression_opt, expression, castable_type;

start with goal;

// 19.2) The Syntactic Grammar
goal ::=	compilation_unit
;

compilation_unit ::= compilation_unit method_declaration
                 |   compilation_unit local_variable_declaration
                 |   compilation_unit statement
                 |   /*empty*/
		//import_declarations_opt
		;

// 19.3) Lexical Structure.
literal ::=	INTEGER_LITERAL
	    |	FLOATING_POINT_LITERAL
     	|	BOOLEAN_LITERAL
        |   CHARACTER_LITERAL
     	|	string_literal
	    |	NULL_LITERAL
;

string_literal ::= QUOTE characters QUOTE
;

characters ::= CHARACTER_LITERAL
           |   characters CHARACTER_LITERAL
;

// 19.4) Types, Values, and Variables
type	::=	numeric_type
;

numeric_type  ::=  integral_type
	          |    FLOAT
;

integral_type ::= INT
	          |	  LONG
	          |	  CHAR
;

// 19.5) Names
name	::=	IDENTIFIER
;

variable_declarators ::= variable_declarator
	                 |	 variable_declarators COMMA variable_declarator
;
variable_declarator ::= variable_declarator_id
	                |	variable_declarator_id EQ variable_initializer
;
variable_declarator_id ::= name
	                   |   variable_declarator_id LBRACK RBRACK
;
variable_initializer ::= expression
	                 |	 array_initializer
;

// 19.8.3) Method Declarations
method_declaration ::= method_header method_body
;
method_header ::= type method_declarator
	          |	  VOID method_declarator
;

method_declarator ::= name LPAREN formal_parameter_list_opt RPAREN
;

formal_parameter_list_opt ::= formal_parameter_list
	                      |
;

formal_parameter_list ::= formal_parameter
	                  |	  formal_parameter_list COMMA formal_parameter
;

formal_parameter ::= type variable_declarator_id
;

method_body ::=	block
	        |   SEMICOLON
;

// 19.10) Arrays
array_initializer ::= LBRACE variable_initializers RBRACE
	              |	  LBRACE RBRACE
;

variable_initializers ::= variable_initializer
	                  |	  variable_initializers COMMA variable_initializer
;

// 19.11) Blocks and Statements
block ::= LBRACE block_statements_opt RBRACE
;

block_statements_opt ::= block_statements
                	 |
;

block_statements ::= block_statement
	             |	 block_statements block_statement
;

block_statement ::= local_variable_declaration_statement
	            |	statement
;

local_variable_declaration_statement ::= local_variable_declaration SEMICOLON
;

local_variable_declaration ::= type variable_declarators
;

statement ::=	statement_without_trailing_substatement
            |	if_then_statement
        	|	if_then_else_statement
        	|	while_statement
;

statement_without_trailing_substatement ::= block
	                                    |	empty_statement
	                                    |	expression_statement
	                                    |	return_statement
;

empty_statement ::= SEMICOLON
;

expression_statement ::= statement_expression SEMICOLON
;

statement_expression ::= assignment
	                 |   method_invocation
;

if_then_statement ::= IF LPAREN expression RPAREN block
;

if_then_else_statement ::= IF LPAREN expression RPAREN block ELSE block
;

while_statement ::= WHILE LPAREN expression RPAREN REPEAT block
;

return_statement ::= RETURN expression_opt SEMICOLON
;

// 19.12) Expressions
primary ::=	primary_no_new_array
	    |	array_creation_expression
;

primary_no_new_array ::= literal
	                 |	method_invocation
	                 |	array_access
;

argument_list_opt ::= argument_list
	              | /* Empty */
;

argument_list ::= expression
	          |	  argument_list COMMA expression
;

array_creation_expression ::= type ARRAY name assignment_operator LBRACK comma_seperated_values RBRACK
;

comma_seperated_values ::= literal
                       |   comma_seperated_values COMMA literal
                       |   /* empty */
;

method_invocation ::= name LPAREN argument_list_opt RPAREN
;

array_access ::= name LBRACK expression RBRACK
;

postfix_expression ::= primary
	               |   name
;

unary_expression ::= PLUS unary_expression
                 |   MINUS unary_expression
	             |	 unary_expression_not_plus_minus
;

unary_expression_not_plus_minus ::= postfix_expression
	                            |	cast_expression
;

cast_expression ::= LPAREN type RPAREN castable_type
;

castable_type ::= name
              |   method_invocation
              |   array_access
;

multiplicative_expression ::= unary_expression
	                      |	  multiplicative_expression MULT unary_expression
	                      |	  multiplicative_expression DIV unary_expression
;

additive_expression ::= multiplicative_expression
	                |	additive_expression PLUS multiplicative_expression
	                |	additive_expression MINUS multiplicative_expression
;

equality_expression ::= relational_expression
                	|	equality_expression IS relational_expression
                	|	equality_expression ISNOT relational_expression
;

relational_expression ::= relational_expression LT additive_expression
	                  |	  relational_expression GT additive_expression
;

and_expression ::= or_expression
	           |   and_expression AND or_expression
;

or_expression ::= equality_expression
              |	  or_expression OR equality_expression
;

assignment_expression ::= and_expression
	                  |	  assignment
;

assignment ::=	left_hand_side assignment_operator assignment_expression
;

left_hand_side ::= name
	           |   array_access
;

assignment_operator ::= EQ
;

expression_opt ::= expression
	           | /* Empty */
;

expression ::=	assignment_expression
;
